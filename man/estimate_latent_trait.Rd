% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_latent_trait.R
\name{estimate_latent_trait}
\alias{estimate_latent_trait}
\title{Latent trait estimation}
\usage{
estimate_latent_trait(estimate, responses, prior, model, administered,
  number_dimensions, estimator, alpha, beta, guessing,
  number_itemsteps_per_item, lower_bound, upper_bound,
  prior_var_safe_nlm = NULL)
}
\arguments{
\item{estimate}{vector containing theta estimate, with covariance matrix as an attribute}

\item{responses}{vector with person responses}

\item{prior}{prior covariance matrix for theta}

\item{model}{string, one of '3PLM', 'GPCM', 'SM' or 'GRM', for the three-parameter logistic, generalized partial credit, sequential or graded response model respectively}

\item{administered}{vector with indeces of administered items}

\item{number_dimensions}{number of dimensions}

\item{estimator}{type of estimator to be used, one of "maximum_aposteriori", "maximum_likelihood", or "expected_aposteriori"}

\item{alpha}{matrix of alpha paramteres}

\item{beta}{matrix of beta paramteres}

\item{guessing}{matrix of guessing parameters}

\item{number_itemsteps_per_item}{vector containing the number of non missing cells per row of the beta matrix}

\item{lower_bound}{vector with lower bounds for theta per dimension; estimated theta values smaller than the lowerbound values are truncated to the lowerbound values}

\item{upper_bound}{vector with upper bounds for theta per dimension; estimated theta values larger than the upperbound values are truncated to the upperbound values}

\item{prior_var_safe_nlm}{if not NULL, expected a posteriori estimate with prior variance(s) equal to prior_var_safe_ml is computed instead of maximum_likelihood/maximum_aposteriori, if maximum_likelihood/maximum_aposteriori estimate fails. Can be a scalar 
(if variance for each dimension is equal) or vector}
}
\value{
vector containing the updated estimate with the covariance matrix as attribute
}
\description{
maximum likelihood, maximum a posteriori and expected a posteriori estimates.
}
\details{
Obtains a latent trait estimate and variance of the estimate.
}
\section{Maximum Likelihood and Maximum A Posteriori}{

Maximum Likelihood and Maximum A-Posteriori estimates are based on a Newton-type non-linear minimization algorithm,
and handled with package \code{\link{nlm}}.
}

\section{Expected A Posteriori}{

Expected A-Posteriori estimates require the repeated evaluation of Q nested integrals, where Q is the dimensionality of the test.
This is performed with adaptive multidimensional Gauss-Hermite quadrature, and handled by package MultiGHQuad, see the documentation there for further details.
Note that the number of quadrature points used rises exponentially with the dimensionality of the test - use of EAP estimates with 
a 3+ dimensional test may not be a good idea.
}

\section{Weighted Maximum Likelihood}{

TODO: UPDATE WITH REFERENCES - MORE PRECISE DETAILS.
Note that WML estimation is not included. There is no satisfying solution to multidimensional Weighted Maximum Likelihood Estimation,
current WML estimators as used in other sources do not account for the covariance between dimensions.
}

\section{Variance}{

Covariance matrix of the estimate is added to the estimate as an attribute.
}
\examples{
number_dimensions <- 1
estimate <- rep(.3, number_dimensions)
model <- "3PLM"
number_items <- 50
responses <- rep(c(1, 0), 17)
administered <- c(6:20, 31:49)
alpha <- matrix(runif(number_items * number_dimensions, .3, 1.5), nrow = number_items, ncol = number_dimensions)
beta <- matrix(rnorm(number_items), nrow = number_items, ncol = 1)
guessing <- c(rep(.1, number_items / 2), rep(.2, number_items / 2))
number_itemsteps_per_item <- number_non_missing_cells_per_row(beta)
lower_bound <- rep(-3, number_dimensions)
upper_bound <- rep(3, number_dimensions)
prior <- diag(1)
prior_var_safe_nlm <- diag(number_dimensions)

# obtain estimates
estimator <- "maximum_likelihood"
ML <- estimate_latent_trait(estimate, responses, prior, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item, lower_bound, upper_bound, prior_var_safe_nlm)
estimator <- "maximum_aposteriori"
MAP <- estimate_latent_trait(estimate, responses, prior, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item, lower_bound, upper_bound, prior_var_safe_nlm)
estimator <- "expected_aposteriori"
EAP <- estimate_latent_trait(estimate, responses, prior, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item, lower_bound, upper_bound, prior_var_safe_nlm)
ML; MAP; EAP

# access variance
attr(ML, "variance")

# Note that expected_aposteriori takes considerably more time when dimensionality is higher...
number_dimensions <- 5
estimate <- rep(.3, number_dimensions)
alpha <- matrix(runif(number_items * number_dimensions, .3, 1.5), nrow = number_items, ncol = number_dimensions)
lower_bound <- rep(-3, number_dimensions)
upper_bound <- rep(3, number_dimensions)
prior <- diag(number_dimensions) 

estimator <- "maximum_aposteriori"
system.time(estimate_latent_trait(estimate, responses, prior, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item, lower_bound, upper_bound, prior_var_safe_nlm = diag(number_dimensions)))
estimator <- "expected_aposteriori"
system.time(estimate_latent_trait(estimate, responses, prior, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item, lower_bound, upper_bound))

}

