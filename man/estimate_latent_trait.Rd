% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_latent_trait.R
\name{estimate_latent_trait}
\alias{estimate_latent_trait}
\title{Latent trait estimation}
\usage{
estimate_latent_trait(estimate, answers, prior_form, prior_parameters, model,
  administered, number_dimensions, estimator, alpha, beta, guessing,
  number_itemsteps_per_item, safe_eap = FALSE,
  eap_estimation_procedure = "riemannsum")
}
\arguments{
\item{estimate}{Vector containing theta estimate, with covariance matrix as an attribute}

\item{answers}{Vector with person answers}

\item{prior_form}{String indicating the form of the prior; one of "normal" or "uniform"}

\item{prior_parameters}{List containing mu and Sigma of the normal prior: list(mu = ..., Sigma = ...), or 
the upper and lower bound of the uniform prior: list(lower_bound = ..., upper_bound = ...). Sigma should always
be in matrix form.}

\item{model}{String, one of '3PLM', 'GPCM', 'SM' or 'GRM', for the three-parameter logistic, generalized partial credit, sequential or graded response model respectively}

\item{administered}{Vector with indeces of administered items}

\item{number_dimensions}{Number of dimensions}

\item{estimator}{Type of estimator to be used, one of "maximum_aposteriori", "maximum_likelihood", or "expected_aposteriori"}

\item{alpha}{Matrix of alpha paramteres}

\item{beta}{Matrix of beta paramteres}

\item{guessing}{Matrix of guessing parameters}

\item{number_itemsteps_per_item}{Vector containing the number of non missing cells per row of the beta matrix}

\item{safe_eap}{Only relevant if estimator is espected_aposteriori. 
TRUE if estimator should switch to maximum aposteriori if the integration algorithm results in an error.}

\item{eap_estimation_procedure}{String indicating the estimation procedure if estimator is expected aposteriori. One of "riemannsum" for integration via Riemannsum or
"gauss_hermite_quad" for integration via Gaussian Hermite Quadrature.}
}
\value{
vector containing the updated estimate with the covariance matrix as attribute
}
\description{
maximum likelihood, maximum a posteriori and expected a posteriori estimates.
}
\details{
Obtains a latent trait estimate and variance of the estimate.
}
\section{Maximum Likelihood and Maximum A Posteriori}{

Maximum Likelihood and Maximum A-Posteriori estimates are based on a Newton-type non-linear minimization algorithm,
and handled with package \code{\link{nlm}}.
}

\section{Expected A Posteriori}{

Expected A-Posteriori estimates require the repeated evaluation of Q nested integrals, where Q is the dimensionality of the test.
This is performed with an adaptive Riemannsum or multidimensional Gauss-Hermite quadrature, the latter handled by package MultiGHQuad, see the documentation there for further details.
Note that the number of quadrature points used rises exponentially with the dimensionality of the test - use of EAP estimates with 
a 3+ dimensional test may not be a good idea.
}

\section{Weighted Maximum Likelihood}{

TODO: UPDATE WITH REFERENCES - MORE PRECISE DETAILS.
Note that WML estimation is not included. There is no satisfying solution to multidimensional Weighted Maximum Likelihood Estimation,
current WML estimators as used in other sources do not account for the covariance between dimensions.
}

\section{Variance}{

Covariance matrix of the estimate is added to the estimate as an attribute.
}
\examples{
number_dimensions <- 1
estimate <- rep(.3, number_dimensions)
model <- "3PLM"
number_items <- 50
answers <- rep(c(1, 0), 17)
administered <- c(6:20, 31:49)
alpha <- matrix(runif(number_items * number_dimensions, .3, 1.5), nrow = number_items, ncol = number_dimensions)
beta <- matrix(rnorm(number_items), nrow = number_items, ncol = 1)
guessing <- c(rep(.1, number_items / 2), rep(.2, number_items / 2))
number_itemsteps_per_item <- number_non_missing_cells_per_row(beta)
prior_form <- "normal"
prior_parameters <- list(mu = 0, Sigma = diag(1))

# obtain estimates
estimator <- "maximum_aposteriori" # maximum a posteriori combined with uniform prior is equivalent to maximum likelihood with bounds
ML <- estimate_latent_trait(estimate, answers, prior_form = "uniform", prior_parameters = list(lower_bound = -4, upper_bound = 4), model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item)
estimator <- "maximum_aposteriori"
MAP <- estimate_latent_trait(estimate, answers, prior_form, prior_parameters, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item)
estimator <- "expected_aposteriori"
EAP <- estimate_latent_trait(estimate, answers, prior_form, prior_parameters, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item)
ML; MAP; EAP

# access variance
attr(ML, "variance")

# Note that expected_aposteriori takes considerably more time when dimensionality is higher...
number_dimensions <- 5
estimate <- rep(.3, number_dimensions)
alpha <- matrix(runif(number_items * number_dimensions, .3, 1.5), nrow = number_items, ncol = number_dimensions)
prior_form <- "normal"
prior_parameters <- list(mu = rep(0, number_dimensions), Sigma = diag(number_dimensions))

estimator <- "maximum_aposteriori"
system.time(estimate_latent_trait(estimate, answers, prior_form, prior_parameters, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item))
estimator <- "expected_aposteriori"
system.time(estimate_latent_trait(estimate, answers, prior_form, prior_parameters, model, administered, number_dimensions, estimator, alpha, beta, guessing, number_itemsteps_per_item))

}

