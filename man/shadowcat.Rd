% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shadowcat.R
\name{shadowcat}
\alias{shadowcat}
\title{Returns a list with the key of the next item to be administered given a new answer,
an updated estimate of theta, updated covariance matrix of theta converted to a vector, and the answers to the administered items}
\usage{
shadowcat(answers, estimate, variance, model, alpha, beta, start_items,
  stop_test, estimator, information_summary, prior_form = NULL,
  prior_parameters = NULL, guessing = NULL, eta = NULL,
  constraints_and_characts = NULL, lower_bound = NULL, upper_bound = NULL,
  safe_maximum = FALSE, prior_var_safe_ml = NULL,
  eap_estimation_procedure = "riemannsum")
}
\arguments{
\item{answers}{named list of previous answers and new answer, with names being the item keys; should be initialized with NULL}

\item{estimate}{vector with estimate of latent trait theta}

\item{variance}{(co)variance matrix of the estimate, as vector}

\item{model}{String, one of '3PLM', 'GPCM', 'SM' or 'GRM', for the three-parameter logistic, generalized partial credit, sequential or graded response model respectively.}

\item{alpha}{Matrix of alpha parameters, one column per dimension, one row per item. Row names should contain the item keys. Note that so called within-dimensional models still use an alpha matrix, they simply 
have only one non-zero loading per item.}

\item{beta}{Matrix of beta parameters, one column per item step, one row per item. Row names should contain the item keys. Note that ShadowCAT expects answer categories to be sequential,
and without gaps. That is, the weight parameter in the GPCM model is assumed to be sequential, and equal to the position of the 'location' of the beta parameter in the Beta matrix.
The matrix will have a number of columns equal to the largest number of answer categories, items with fewer answer categories should be 
right-padded with \code{NA}. \code{NA} values between answer categories are not allowed, and will lead to errors.
Beta matrix can be set to NULL if model is GPCM and eta is defined
More flexibility in Beta parameters might be added in future versions.}

\item{start_items}{items that are shown to the respondent before adaptive proces starts; one of
list(type = 'random', n)
list(type = 'fixed', indeces, n)
list(type = 'random_by_dimension', n_by_dimension, n)
where n = total number of initial items, indeces = vector of initial item indeces, 
n_by_dimension = scalar of number of initial items per dimension, or vector with number of initial items for each dimension
If n is 0, only n needs to be defined
'random_by_dimension' assumes that items load on a single dimension, if any item has a non-zero loading on a dimension, it is considered to be part of that dimension.}

\item{stop_test}{rule for when to stop providing new items to patient; should be a list of the form
list(target = ..., max_n = ..., min_n = ..., cutoffs = ...), 
where max_n = test length at which testing should stop (even if target has not been reached yet in case of variance stopping rule), 
target = vector of maximum acceptable variances per dimension; if target = NULL, only max_n is taken into account,
min_n = minimum test length; NULL means no mimimum test length,
cutoffs = matrix containing cut off values per dimension (columns) and test iteration (rows). First row contains cut off values for when no items have been
administered yet, second row for when one item has been administered, etc. If estimate + 3SE < cutoff for each dimension at certain iteration, test stops; 
NULL means no cut off values}

\item{estimator}{type of estimator to be used, one of "maximum_aposteriori", "maximum_likelihood", or "expected_aposteriori"}

\item{information_summary}{called "objective" by Kroeze; how to summarize information; one of
"determinant": compute determinant(info_sofar_QxQ + info_QxQ_k) for each yet available item k
"posterior_determinant": compute determinant(info_sofar_QxQ_plus_prior_information + info_QxQ_k) for each yet available item k
"trace": compute trace((info_sofar_QxQ + info_QxQ_k) for each yet available item k
"posterior_trace": compute trace(info_sofar_QxQ_plus_prior_information + info_QxQ_k) for each yet available item k
"posterior_expected_kullback_leibler" = compute Posterior expected Kullback-Leibler Information}

\item{prior_form}{String indicating the form of the prior; one of "normal" or "uniform"}

\item{prior_parameters}{List containing mu and Sigma of the normal prior: list(mu = ..., Sigma = ...), or 
the upper and lower bound of the uniform prior: list(lower_bound = ..., upper_bound = ...). Sigma should always
be in matrix form. The length of lower_bound and upper_bound should be equal to the number of dimensions}

\item{guessing}{Matrix with one column of guessing parameters per item. Row names should contain the item keys. Optionally used in 3PLM model, ignored for all others.}

\item{eta}{Matrix of location parameters, optionally used in GPCM model, ignored for all others. Row names should contain the item keys.}

\item{constraints_and_characts}{list with constraints and characteristics; NULL means no constraints
constraints should be specified as a list of constraints, each constraint is a list with three named values;
name: the column name of the characteristic this constraint applies to. For categorical characteristics the level should be specified as name/value.
op: the logical operator to be used. Valid options are "<", "=", ">" and "><".
target: the target value, numeric. If the operator is "><", this should be a length two vector in between which the target should fall.
characteristics should be a data.frame with characteristics, one row per item (rows in the same order as they are in alpha, beta, etc.), one column per characteristic.
See constraints_lp_format() for details}

\item{lower_bound}{Vector with lower bounds for theta per dimension; estimated theta values smaller than the lowerbound values are truncated to the lowerbound values.
Can only be defined when estimator is maximum_likelihood. Setting bounds with maximum likelihood estimation is equivalent to
using maximum aposteriori estimation with a uniform prior.}

\item{upper_bound}{Vector with upper bounds for theta per dimension; estimated theta values larger than the upperbound values are truncated to the upperbound values
Can only be defined when estimator is maximum_likelihood. Setting bounds with maximum likelihood estimation is equivalent to
using maximum aposteriori estimation with a uniform prior.}

\item{safe_maximum}{Only relevant if estimator is maximum likelihood or maximum aposteriori. 
TRUE if estimator should switch to expected aposteriori if the maximization algorithm results in an error or warning.
A normal prior with mean zero and variance equal to prior_var_safe_ml is used if estimator is maximum likelihood. The 
already defined prior settings are used otherwise.}

\item{prior_var_safe_ml}{Scalar or vector containing the prior variance for theta if safe_ml is TRUE and estimator is maximum likehood.}

\item{eap_estimation_procedure}{String indicating the estimation procedure if estimator is expected aposteriori. One of "riemannsum" for integration via Riemannsum or
"gauss_hermite_quad" for integration via Gaussian Hermite Quadrature.}
}
\value{
a list containing the key of the next item to be administered given a new answer (or "stop_test"), 
updated estimate of theta, updated covariance matrix of theta converted to a vector, and the answers to the administered items (named list)
}
\description{
Returns a list with the key of the next item to be administered given a new answer,
an updated estimate of theta, updated covariance matrix of theta converted to a vector, and the answers to the administered items
}

