
R version 3.2.0 (2015-04-16) -- "Full of Ingredients"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ShadowCAT"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ShadowCAT')
Loading required package: mvtnorm
Loading required package: MultiGHQuad
Loading required package: numDeriv
Loading required package: plot3D
Loading required package: lpSolve
Loading required package: rredis
Loading required package: jsonlite

Attaching package: ‘jsonlite’

The following object is masked from ‘package:utils’:

    View

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("answer")
> ### * answer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: answer
> ### Title: Simulate response(s)
> ### Aliases: answer
> 
> ### ** Examples
> 
> items <- createTestBank("GPCM")
> test <- initTest(items)
> person <- initPerson(items)
> 
> # simulates responses to all questions, and returns a vector response pattern.
> answer(person, test)
 [1] 2 2 3 2 2 0 2 1 2 2 2 3 2 2 2 2 1 1 2 2 3 3 2 2 1 3 3 2 3 2 0 2 4 2 3 0 3 2
[39] 3 3 2 3 0 3 0 2 2 2 2 4
> 
> # simulates responses to the specified question indeces, and returns an updated person object.
> answer(person, test, sample(test$items$K, 5))
$theta
[1] 0

$prior
     [,1]
[1,]    1

$estimate
[1] 0
attr(,"variance")
     [,1]
[1,]    1

$variance
     [,1]
[1,]    1

$available
 [1]  1  2  3  4  5  6  7  8 10 12 15 16 17 18 19 20 21 22 23 24 26 27 28 29 30
[26] 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50

$administered
[1] 14 11 25 13  9

$responses
[1] 1 2 0 2 3

attr(,"class")
[1] "ShadowCAT.person"
> 
> 
> 
> cleanEx()
> nameEx("createConstraints")
> ### * createConstraints
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: createConstraints
> ### Title: Creates a constraints object.
> ### Aliases: createConstraints
> 
> ### ** Examples
> 
> # set up a simple itembank and test.
> items <- createTestBank("GPCM")
> test <- initTest(items, selection = "Shadow" , objective = "PEKL")
> 
> # set up some dummy characteristics.
> content <- sample(c('algebra','physics','calculus'), items$K, TRUE)
> time <- rnorm(items$K)
> exclusive <- rep(0, items$K)
> exclusive[sample(items$K, 4)] <- 1
> 
> # bind them in a data.fame
> characteristics <- data.frame(content, time, exclusive)
> 
> # set up the constraints
> constraints <- list(
+   list(name = 'content/algebra',
+        op = '><',
+        target = c(5,10)),
+   list(name = 'content/physics',
+        op = '><',
+        target = c(2,5)),
+   list(name = 'time',
+        op = '<',
+        target = 20),
+   list(name = 'exclusive',
+        op = '<',
+        target = 2))
> 
> # update the test object
> test$constraints <- createConstraints(test, characteristics, constraints)
> 
> # or do it all at once;
> test2 <- initTest(items, constraints = list(characteristics = characteristics, constraints = constraints))
> 
> # results are identical (initTest uses createConstraints internally);
> all.equal(test$constraints, test2$constraints)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("estimate")
> ### * estimate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: estimate
> ### Title: Latent trait estimation
> ### Aliases: estimate
> 
> ### ** Examples
> 
> # create a basic test + person
> items <- createTestBank("GPCM")
> test <- initTest(items, estimator = "ML")
> person <- initPerson(items)
> 
> # answer a few items
> person <- answer(person, test, sample(items$K, 10))
> 
> # obtain estimates
> ML <- estimate(person, test)$estimate
> test$estimator <- "MAP"
> MAP <- estimate(person, test)$estimate
> test$estimator <- "EAP"
> EAP <- estimate(person, test)$estimate
> ML; MAP; EAP
[1] -0.3600737
attr(,"variance")
          [,1]
[1,] 0.1820179
[1] -0.3047762
attr(,"variance")
         [,1]
[1,] 0.153174
[1] -0.2693552
attr(,"variance")
          [,1]
[1,] 0.1336652
> 
> # access variance
> attr(ML, "variance")
          [,1]
[1,] 0.1820179
> 
> # Note that EAP takes considerably more time when dimensionality is higher...
> items5d <- createTestBank("GPCM", Q=5)
> test5dEAP <- initTest(items, estimator = "EAP")
> test5dMAP <- initTest(items, estimator = "MAP")
> person5d <- answer(initPerson(items), test, sample(items5d$K, 10))
> 
> system.time(estimate(person5d, test5dEAP))
   user  system elapsed 
  0.014   0.000   0.015 
> system.time(estimate(person5d, test5dMAP))
   user  system elapsed 
  0.003   0.001   0.003 
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.442 0.018 0.482 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
